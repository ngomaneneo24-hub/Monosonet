input {
  beats {
    port => 5044
  }
}

filter {
  # Add service name from docker metadata when available
  if [container] and [container][name] {
    mutate { add_field => { "service.name" => "%{[container][name]}" } }
  }

  # Try to parse JSON messages directly
  json {
    source => "message"
    target => "json"
    skip_on_invalid_json => true
  }

  if ![json] {
    # Fallback grok for typical spdlog pattern: [ts] [LEVEL] message
    grok {
      match => { "message" => ["\\[%{TIMESTAMP_ISO8601:ts}\\] \\[%(?:TRACE|DEBUG|INFO|WARN|ERROR|CRITICAL|OFF)\:]{0,0}\\[%{LOGLEVEL:level}\\] %{GREEDYDATA:msg}", "\\[%{TIMESTAMP_ISO8601:ts}\\] \\[%{LOGLEVEL:level}\\] %{GREEDYDATA:msg}"] }
      tag_on_failure => []
    }
    date {
      match => ["ts", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss,SSS"]
      target => "@timestamp"
      remove_field => ["ts"]
    }
  } else {
    mutate {
      add_field => {
        "level" => "%{[json][level]}"
        "msg" => "%{[json][msg]}"
      }
      remove_field => ["json"]
    }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "sonet-logs-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}